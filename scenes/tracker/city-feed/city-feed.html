<!--
Copyright 2015 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->
<link rel="import" href="../../../components/polymer/polymer.html">
<link rel="import" href="../../../components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../components/iron-list/iron-list.html">
<link rel="import" href="../../../components/iron-pages/iron-pages.html">
<link rel="import" href="../../../components/iron-selector/iron-selector.html">
<link rel="import" href="../../../components/iron-image/iron-image.html">
<link rel="import" href="../../../components/google-streetview-pano/google-streetview-pano.html">
<link rel="import" href="../../../components/iron-media-query/iron-media-query.html">

<!--
Utility element to use response HTML returned by the Santa Tracker API.
-->
<dom-module id="html-echo">
<script>
Polymer({
  is: 'html-echo',

  properties: {
    html: {
      type: String,
      value: null,
      observers: '_htmlChanged'
    }
  },

  _htmlChanged: function() {
    if (this.html) {
      Polymer.dom(this).innerHTML = this.html;
    }
  }
});
</script>
</dom-module>

<!-- TODO(samthor): Upgrade styling for Polymer 1+ (#1165) -->
<link rel="stylesheet" href="city-feed.css">

<!--
City feed view in Tracker
-->
<dom-module id="city-feed">
<template>
<style>
  :host {
    display: none;
  }
  :host([active]) {
    display: block;
  }

  .divider {
    @apply(--layout-horizontal);
    @apply(--layout-end);
  }

  .horizontal {
    @apply(--layout-horizontal);
  }

  .centered {
    @apply(--layout-center);
  }

  .start-justified {
    @apply(--layout-start-justified);
  }

  .fit {
    @apply(--layout-fit);
  }

  .flex {
    @apply(--layout-flex);
  }
</style>

<template id="mini-cards-template">
  <div hidden$="{{!modelTypeIs_('facts')}}">
    <div class="card-header">
      <div class="corner-image"></div>
      <h4><i18n-msg msgid="tracker_world_facts">PLACEHOLDER_i18n</i18n-msg></h4>
    </div>
    <div class="card-body">
      <p>{{model.didyouknow}}</p>
    </div>
    <div class="card-footer">
      <p><i18n-msg msgid="trivia_ngb_promo">PLACEHOLDER_i18n</i18n-msg></p>
    </div>
  </div>

  <div hidden$="{{!modelTypeIs_('photos')}}" style="height: 100%">
    <div class="card-header">
      <div class="corner-image"></div>
    </div>
    <div class="card-body">
      <iron-image sizing="cover" preload load="{{model.imageUrl}}" fade src="{{model.imageUrl}}"></iron-image>
    </div>
  </div>

  <div hidden$="{{!modelTypeIs_('scene')}}" style="height: 100%">
    <a href="{{pageUrl}}#{{model.game}}">
      <div class="card-header">
        <div class="corner-image"></div>
      </div>
      <div class="card-body"></div>
    </a>
  </div>

  <div hidden$="{{!modelTypeIs_('update')}}">
    <div class="card-header">
      <div class="corner-image"></div>
      <h4><i18n-msg msgid="tracker_santa_update">PLACEHOLDER_i18n</i18n-msg></h4>
    </div>
    <div class="card-body">
      <p>{{model.status}}</p>
    </div>
  </div>

  <div hidden$="{{!modelTypeIs_('video')}}">
    <a href="{{pageUrl}}#{{videoMap[model.youtubeId]}}">
      <div class="card-header">
        <div class="corner-image"></div>
        <h4><i18n-msg msgid="santatracker">PLACEHOLDER_i18n</i18n-msg></h4>
        <h3><i18n-msg msgid="watch">PLACEHOLDER_i18n</i18n-msg></h3>
      </div>
      <div class="card-body card-{{videoMap[model.youtubeId]}}"></div>
    </a>
  </div>
</template>

<div id="module-city-feed" class="fit">
  <div class="scene fit">

    <iron-media-query query="(max-width:960px)"
        query-matches="{{isMobileSize}}"></iron-media-query>

    <iron-list id="feed" data="{{stream}}" selection-enabled="false"
               height="350" on-scroll="onScroll">
      <template>
        <div layout$="{{!isMobileSize}}" class="horizontal start-justified">
          <!-- TODO: When this is fully ported, it should use the flex
            class, not attribute -->
          <div class="card card-{{model.type}} {{model.game ? 'card-' + model.game : ''}}"
               flex$="{{modelTypeIs_('city')}}">
            <div class="divider">{{model.timestamp | formatTime}}</div>

            <div hidden?="{{model.type != 'city'}}">
              <div class="card-header">
                <div class="corner-image"></div>
                <div>
                  <h4 class="white">{{model.stop.region}}</h4>
                  <h1>{{model.stop.city}}</h1>
                </div>
                <iron-selector id="cardselector" class="card-icons" selected="{{model.selectedCard}}"
                      on-iron-activate="onCardSelected">
                  <img src="img/tracker-and-city-SVGs_feed-city-icon.svg" data-name="photo" hidden?="{{!model.stop.details.photos[0]}}">
                  <img src="img/tracker-and-city-SVGs_feed-city-photo-icon.svg" data-name="photo" hidden?="{{!model.stop.details.photos[1]}}">
                  <img src="img/tracker-and-city-SVGs_feed-city-sv-icon.svg" data-name="streetview" hidden?="{{!model.stop.details.streetView}}">
                  <img src="img/tracker-and-city-SVGs_feed-city-wiki-icon.svg" on-tap="{{onWikipedia}}" data-name="wikipedia" hidden?="{{!model.stop.details.hasWiki}}">
                </iron-selector>
                <div class="stats">
                  <div class="horizontal">
                    <div>
                      <h4><i18n-msg msgid="tracker_arrival">PLACEHOLDER_i18n</i18n-msg></h4>
                      <div class="horizontal centered">
                        <div class="ico ico-clock"></div>
                        <h2 class="stat-large">{{model.stop.arrival | formatTime}}</h2>
                      </div>
                    </div>
                    <div>
                      <h4><i18n-msg msgid="tracker_weather">PLACEHOLDER_i18n</i18n-msg></h4>
                      <div class="horizontal centered">
                        <div class="ico ico-weatherchanel"></div>
                        <h2 class="stat-large white">{{model.stop.details.weather.tempC}}&deg;C / {{model.stop.details.weather.tempF}}&deg;F</h2>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <iron-pages class="card-body" selected="{{model.selectedCard}}">
                <div>
                  <iron-image sizing="cover" load?="{{model.stop.details.photos[0]}}" preload fade src="{{model.stop.details.photos[0].url}}"></iron-image>
                  <div class="attribution" hidden?="{{!model.stop.details.photos[0]}}">
                    <span class="attrib"><html-echo html="{{model.stop.details.photos[0].attributionHtml}}"></html-echo></span><span class="addview">Add your own <a href="https://www.google.com/maps/views/home">photos</a> to {{model.stop.city}}</span>
                  </div>
                </div>
                <div>
                  <iron-image sizing="cover" preload load?="{{model.stop.details.photos[1]}}" fade src="{{model.stop.details.photos[1].url}}"></iron-image>
                  <div class="attribution" hidden?="{{!model.stop.details.photos[1]}}">
                    <span class="attrib"><html-echo html="{{model.stop.details.photos[1].attributionHtml}}"></html-echo></span><span class="addview">Add your own <a href="https://www.google.com/maps/views/home">photos</a> to {{model.stop.city}}</span>
                  </div>
                </div>
                <div>
                  <template if="{{model.stop.details.streetView}}">
                    <template if="{{model.selectedCard == 2}}">
                      <google-streetview-pano version="3.exp" class="fit"
                          panoid="{{model.stop.details.streetView.id}}"
                          heading="{{model.stop.details.streetView.heading}}"
                          client-id="{{santaApp.config.CLIENT_ID}}"
                          libraries="places,geometry"
                          language="{{santaApp.language}}"
                          disable-default-ui></google-streetview-pano>
                    </template>
                  </template>
                </div>
                <div class="wikipedia">
                  <div class="gradientbar"></div>
                  <div class="wikipedia__logo"></div>
                  <html-echo class="wikipedia__body" html="{{model.stop.details.wikipedia.excerpt}}"></html-echo>
                  <div class="attribution">
                    <span class="wiki-cc">Available under
                    <a target="wiki" href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>
                    terms</span>
                    <a target="wiki" href="{{model.stop.details.wikipedia.url}}">{{model.stop.details.wikipedia.url}}</a>
                  </div>
                </div>
              </iron-pages>
            </div>

            <template bind ref="mini-cards-template"></template>
          </div>

          <template is="dom-if" if="{{model.nextCard}}" bind="{{model.nextCard as model}}">
            <div class="card card-{{model.nextCard.type}} {{model.nextCard.game ? 'card-' + model.nextCard.game : ''}}">
              <div class="divider">{{formatTime(model.nextCard.timestamp)}}</div>
              <template bind ref="mini-cards-template"></template>
            </div>
          </template>

        </div>

      </template>
    </iron-list>

  </div>
</div>

</template>
<script>
(function() {

/**
 * Fired when a page in the city card is selected or a video is played.
 *
 * @event analytics-track-event
 * @param {object} detail
 */

/**
 * Lookup table of destination id -> index into timeline array.
 *
 * @type object
 * @default {}
 * @private
 */
var destLookup_ = {};

var CARD_CENTERED_THRESHOLD = 100; // Top/bottom margin of a stream card to declare it as centered on screen.

//  attributes="active location timeline santaApp videoMap"

Polymer({
  is: 'city-feed',

  properties: {

    /**
     * If `true`, the feed is showing.
     */
    active: {
      type: Boolean,
      value: false,
      reflectToAttribute: true,
      observer: 'activeChanged'
    },

    /**
     * Current timeline feed.
     */
    timeline: {
      type: Array,
      value: function() {
        return [];
      },
      observer: 'timelineChanged'
    },

    /**
     * The timeline feed with additional data and adjusted to support mini cards.
     */
    stream: {
      type: Array,
      value: function() {
        return [];
      }
    },

    /**
     * A `<santa-app>` controller element.
     * TODO(samthor): Like for scenes, find this from parent elements
     */
    santaApp: {
      type: Object,
      value: null
    },

    /**
     * Mapping of YouTube video ids to URL routes.
     */
    videoMap: {
      type: Object,
      value: null
    },

    /**
     * The timestamp of the card which is currently visible in the center of
     * the stream.
     */
    cardInView: {
      type: Number,
      value: null
    },

  },

  /**
   * A basename for links within Santa Tracker. The hash is removed for nicer
   * display URLs in the status bar.
   * @property pageUrl
   * @type string
   * @default
   */
  get pageUrl() {
    return location.href.substr(0, location.href.length - location.hash.length);
  },

  /**
   * The last scroll operation that was attempted.
   */
  pendingScroll_: null,

  /**
   * True if the list has done its metrics setup and is ready to be shown.
   */
  setupDone_: false,

  /**
   * True if a scroll update has been queued, due to the user scrolling the stream.
   */
  updateQueued_: false,

  created: function() {
    this.location = {};
    this.pendingScroll_ = {};
  },

  activeChanged: function() {
    if (this.active) {
      // TODO(ericbidelman): shouldn't have to call this with new iron-list. Investigate.
      //this.$.feed.updateSize();
      this.$.feed.notifyResize();

      this.setupDone_ = true;

      if (this.pendingScroll_.func) {
        this.async(function() {
          this.pendingScroll_.func.call(this, this.pendingScroll_.arg);
          this.pendingScroll_ = {};
        });
      }
    } else {
      this.cardInView = null;

      // Remove any deep link URL params when stream is hidden.
      var newHref = location.href.substr(0,
                    location.href.length - location.hash.length) + '#tracker';
      window.history.replaceState(null, '', newHref);

      // Want the list to scroll fast and streetview is a hog. Make sure no
      // streetview cards are activated when the list is opened again.
      if (this.stream) {
        for (var i = 0, item; item = this.stream[i]; ++i) {
          item.selectedCard = 0;
        }
      }
    }
  },

  timelineChanged: function() {
    if (!this.timeline || !this.timeline.length) {
      return;
    }

    // Make a copy so 2-way bindings don't alter original timeline data.
    var stream = this.timeline.slice();

    // Add additional metadata needed by the template.
    for (var i = 0, item; item = stream[i]; ++i) {
      item.selectedCard = 0; // select initial page on destination card.
    }

    var adjustedStream = [];
    destLookup_ = {};

    // iron-list uses a single template to render a linear list of items. To
    // support side-by-side mini cards, we pair mini cards together by storing
    // a reference to the next mini card when it is followed by a subsequent
    // mini card. The reference to the next mini card is used in the iron-list
    // template to determine if an additional card should be rendered in the
    // same row. The template is wrapped in a flexbox container (<div
    // class="layout horizontal start justified">) which handles the layout.
    for (var i = 0, item; item = stream[i]; ++i) {
      var nextCard = stream[i + 1];
      if (item.type == 'city') {
        // Cache index of stop to be able to scroll to destination.
        destLookup_[item.stop.id] = adjustedStream.length;
      } else if (item.type != 'city' && nextCard && nextCard.type != 'city') {
        item.nextCard = nextCard;
        i++; // skip next item in array.
      }
      adjustedStream.push(item);
    }

    this.stream = adjustedStream;

    if (this.active && this.cardInView) {
      this.scrollToTime(this.cardInView);
    }
  },

  /**
   * Scrolls the stream to the given destination card. If the index doesn't exist,
   * the stream scrolls to the top.
   *
   * @method scrollToDest
   * @param {string} destId Destination id
   */
  scrollToDest: function(destId) {
    var idx = destLookup_[destId] || 0;
    this.scrollToIndex(idx);

    if (this.setupDone_ && this.stream.length) {
      // Add deep link to opened destination.
      var newHref = location.href.substr(0,
                    location.href.length - location.hash.length) +
                    '#tracker?timestamp=' + this.stream[idx].timestamp;
      window.history.replaceState(null, '', newHref);
    }
  },

  /**
   * Scrolls the stream to the item at index.
   *
   * @method scrollToIndex
   * @param {number} idx Index of item to scroll to.
   */
  scrollToIndex: function(idx) {
    if (this.setupDone_) {
      this.$.feed.scrollToIndex(idx);
    } else {
      this.pendingScroll_ = {func: this.scrollToIndex, arg: idx};
    }
  },

  /**
   * Scrolls the stream item.
   *
   * @method scrollToTime
   * @param {number} idx Index of item to scroll to.
   */
  scrollToTime: function(timestamp) {
    var timestamp = parseInt(timestamp);
    for (var i = 0, item; item = this.stream[i]; ++i) {
      if (item.timestamp === timestamp) {
        this.scrollToIndex(i);
        break;
      }
    }
  },

  formatTime: function(timestamp) {
    if (isNaN(timestamp)) {
      return '';
    }

    var dateStamp = new Date(timestamp);

    var seconds = dateStamp.getSeconds();
    var mins = dateStamp.getMinutes();
    var hours = dateStamp.getHours();
    var parts = [padDigits(hours), padDigits(mins), padDigits(seconds)];

    return parts.join(':');
  },

  onWikipedia: function(e, detail, sender) {
    var location = sender.templateInstance.model.model.stop;

    // Don't make details API request if wikipedia article has already been fetched.
    if (location.details.wikipedia) {
      return;
    }

    location.getDetails(function(detail) {
      location.details.wikipedia = detail.wikipedia;
    });
  },

  onCardSelected: function(e, detail, sender) {
    var destId = sender.templateInstance.model.model.stop.id;
    var type = detail.item.getAttribute('data-name');
    this.fire('analytics-track-event', {category: 'citycard', action: type,
                                        label: destId});
  },

  // Determines the most central visible card in the stream's viewport.
  updateCardInView: function() {
    this.updateQueued_ = false;

    var coreListHeight = this.$.feed.offsetHeight;

    for (var i = 0, el; el = this.$.feed.children[i]; ++i) {
      var elBounds = el.getBoundingClientRect();
      if (0 < elBounds.top && elBounds.top < coreListHeight) {
        var yMiddleOfElement = elBounds.top + (elBounds.height / 2);
        var yUpper = (coreListHeight / 2) + CARD_CENTERED_THRESHOLD;
        var yLower = (coreListHeight / 2) - CARD_CENTERED_THRESHOLD;

        // If card is on center of screen, add deep link to URL.
        if (yLower < yMiddleOfElement && yMiddleOfElement < yUpper) {
          var timestamp = el.templateInstance.model.model.timestamp;

          this.cardInView = timestamp;

          var newHref = location.href.substr(0,
                        location.href.length - location.hash.length) + '#tracker?timestamp=' + timestamp;
          window.history.replaceState(null, '', newHref);

          break;
        }
      }
    }
  },

  onScroll: function(e, detail, sender) {
    // Debounce scrolling.
    if (!this.updateQueued_) {
      this.async(function() {
        this.updateCardInView();
      });
    }

    this.updateQueued_ = true;
  },

  modelTypeIs_: function(type) {
    return type == this.model.type;
  }

});

})();
</script>
</dom-module>
