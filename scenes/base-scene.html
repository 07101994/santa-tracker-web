<link rel="import" href="../components/polymer/polymer.html">

<!--
A base class element for Santa Tracker scenes. Should not be declared directly,
but extended by other elements.

### Scene methods

Subclass scene elements are expected to implement the following methods as needed.
These methods will be called at the appropriate times:

- `onPreload` - called to preload assets. Scenes should call `preloadImages` and/or `preloadSounds` inside this method.
- `onShow` - if applicable, preloading has completed. The scene is revealed.
- `onHide` - the scene is hidden.
- `onPause` - the scene has been paused due to page visibility hidden or window blur. Scenes should use this method to stop animations, sounds, etc.
- `onResume` - the scene has been resumed due to page visibility unhidden or window focus. Scenes should use this method to restart animations, sounds, etc.

### Scene properties

Subclass scene elements can define the following properties:

- `componentDir` - the relative path to the component's root folder from the main app folder (e.g 'scenes/village/').
- `loadingBgColor` - an optional loading screen background color.
- `loadingSrc` - an optional loading screen background image. The path should be relative to the
  component's folder (e.g 'img/loading.gif').

@element base-scene
-->

<!-- Outside base-scene so we don't have to create extra an Shadow DOM. -->
<style shim-shadowdom>
  body /deep/ [alwaysActive] {
    visibility: visible;
    z-index: initial;
  }
</style>

<polymer-element name="base-scene" attributes="active alwaysActive path route mode santaApp loadingBgColor loadingSrc"
                 on-scene-pause="{{handlePause}}" tabindex="0">
<script>
(function() {

var scheduleChecked_ = false; // static

Polymer({
  publish: {
    /**
     * If `true`, the scene is selected.
     *
     * @attribute active
     * @type bool
     * @default false
     */
    active: {value: false, reflect: true},

    /**
     * If `true`, the scene is always visible and `hidden` won't be applied
     * when the page's `onHide()` is called.
     *
     * @attribute alwaysActive
     * @type bool
     * @default false
     */
    alwaysActive: {value: false, reflect: true}
  },

  /**
   * URL route for this scene.
   *
   * @attribute route
   * @type string
   * @default null
   */
  route: null,

  /**
   * The mode of the scene. Possible values are: 'cast'.
   *
   * @attribute mode
   * @type string
   * @default ''
   */
  mode: '',

  /**
   * A `<santa-app>` controller element.
   *
   * @attribute santaApp
   * @type HTMLElement
   * @default null
   */
  santaApp: null,

  computed: {
    /**
     * Preloading progress (percentage) of the loaded scene.
     *
     * @property preloadProgress
     * @type number
     * @default 0
     */
    preloadProgress: 'loaded ? 100 : totalAssets ? (assetsLoaded / totalAssets * 100) : 0',
  },

  preloadProgress: 0,

  /**
   * Total number of assets that will need to be preloaded. Must be set
   * in `onPreload` or will be ignored.
   * @property totalAssets
   * @type number
   * @default 0
   */
  totalAssets: 0,

  /**
   * Assets loaded so far (out of `totalAssets`).
   * @property assetsLoaded
   * @type number
   * @default 0
   */
  assetsLoaded: 0,

  /**
   * The path of the scene file (html import) to load.
   *
   * @attribute path
   * @type string
   * @default null
   */
  path: null,

  /**
   * An optional background loading color for the preloading overlay.
   *
   * @attribute loadingBgColor
   * @type string
   * @default null
   */
  loadingBgColor: null,

   /**
   * An optional background image for the preloading overlay.
   *
   * @attribute loadingSrc
   * @type string
   * @default null
   */
  loadingSrc: null,

  /**
   * The relative path of the scene folder from the main app root folder.
   * (e.g 'scenes/village/').
   *
   * @property componentDir
   * @type string
   * @default null
   */
  componentDir: null,

  /**
   * True if the scene has previously been loaded.
   *
   * @property loaded
   * @type bool
   * @default false
   */
  loaded: false,

  /**
   * Max number of milliseconds to wait before timing out and abandoning
   * preload.
   *
   * @property MAX_PRELOAD_TIME
   * @type number
   * @default 30000
   */
  MAX_PRELOAD_TIME: 30 * 1000,

  /**
   * Max preload async handler
   *
   * @type Number|Function
   * @default null
   */
  maxPreloadAsync_: null,

  /**
   * The component's directory. Can be used to reference assets in HTML.
   *
   * @property componentBaseDir
   * @type string
   * @default
   */
  get componentBaseDir() {
    return location.protocol + '//' + location.host + location.pathname +
           (this.componentDir || '');
  },

  ready: function() {
    if (this.loadingSrc) {
      this.loadingSrc = this.componentBaseDir + this.loadingSrc;
    }
  },

  santaAppChanged: function() {
    // Only check initial schedule the first time any scene is created.
    if (!scheduleChecked_) {
      this.santaApp.checkSchedule_(true);
      scheduleChecked_ = true;
    }
  },

  /**
   * A helper method for preloading an array of image URLs.
   * @param {!Array.<string>} imageUrls
   */
  preloadImages: function(imageUrls) {
    this.totalAssets += imageUrls.length;

    var onload = function() {
       this.assetsLoaded++;
    }.bind(this);

    var i = 0;
    var rafCallback = function() {
      var img = new Image();
      img.onerror = img.onload = onload;
      img.src = this.resolvePath(imageUrls[i++]);

      if (i < imageUrls.length) {
        requestAnimationFrame(rafCallback);
      }
    }.bind(this);

    requestAnimationFrame(rafCallback);
  },

  /**
   * Preload a set of sounds for this scene via Klang.
   * @method preloadSounds
   * @param string soundSetName
   */
  preloadSounds: function(soundSetName) {
    this.fire('sound-preload', soundSetName);
  },

  preloadProgressChanged: function() {
    if (this.preloadProgress === 100) {
      this.showScene();
    }
  },

  showScene: function() {
    this.loaded = true;

    // Cancel the max preload async
    this.cancelAsync(this.maxPreloadAsync_);

    if (this.active) {
      this.onShow && this.onShow();
      this.hidden = false;

      // focus in case element needs keyboard events
      this.focus();
    }
  },

  activeChanged: function() {
    if (!this.active) {
      this.onHide && this.onHide();
      if (!this.alwaysActive) {
        this.hidden = true;
      }
      return;
    }

    // If subclass defines preloading, call it. If not, or nothing needs to
    // be preloaded, signal ready.
    if (!this.loaded && this.onPreload) {
      this.onPreload();

      // If assets are queued to preload, schedule showScene on timeout in
      // case preloading fails.
      if (this.totalAssets > 0) {
        this.maxPreloadAsync_ = this.async(this.showScene, null, this.MAX_PRELOAD_TIME);
        return;
      }
    }

    this.showScene();
  },

  handlePause: function(e, paused) {
    if (paused && this.onPause) {
      this.onPause();
    } else if (!paused && this.onResume) {
      this.onResume();
    }
  }
});

})();
</script>
</polymer-element>
